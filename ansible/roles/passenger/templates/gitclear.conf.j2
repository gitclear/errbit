# Adds forwarded IP + request time (see http://nginx.org/en/docs/http/ngx_http_log_module.html#log_format)
log_format gitclear_access '$http_x_forwarded_for - $remote_user [$time_local] '
  '"$request" $status $body_bytes_sent '
  '"$http_referer" "$http_user_agent" $request_time';

server {
    listen 80;

{% if staging is defined %}
    server_name ~^staging(\d+)\.gitclear.com$;

    # This is necessary so it can be referenced in location blocks below (the $1 won't be defined)
    set $staging_instance $1;

    root /home/{{ user }}/gitclear/staging$staging_instance/current/public;
{% else %}
    server_name www.gitclear.com;
    root /home/{{ user }}/gitclear/current/public;
{% endif %}

    access_log /var/log/nginx/gitclear-access.log gitclear_access;
    error_log /var/log/nginx/gitclear-error.log;

    passenger_enabled on;
    passenger_app_type rack;
    passenger_ruby /home/{{ user }}/.rvm/wrappers/ruby-{{ ruby_version }}@{{ ruby_gemset }}/ruby;
    passenger_start_timeout 180;

{% if staging is defined %}
    passenger_app_env staging;
    passenger_min_instances 3;
{% else %}
    passenger_min_instances 7;
{% endif %}

    allow all;

{% if staging is defined %}
    listen 443 ssl; # managed by Certbot
{% if inventory_hostname == 'sos-app2' %}
    ssl_certificate /etc/letsencrypt/live/staging2.gitclear.com/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/staging2.gitclear.com/privkey.pem; # managed by Certbot
{% else %}
    ssl_certificate /etc/letsencrypt/live/staging1.gitclear.com/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/staging1.gitclear.com/privkey.pem; # managed by Certbot
{% endif %}
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot

    if ($scheme != "https") {
        # Note this does not match production, where the Rails application handles the non-ssl redirect. This is here
        # for staging since it is exposed directly, not behind HAProxy like production is.
        return 301 https://$host$request_uri;
    } # managed by Certbot

    if (-f /home/{{ user }}/gitclear/staging$staging_instance/current/tmp/maintenance.txt) {
        return 503;
    }

    location / {
        {{ private_access_directives }}
    }
{% else %}
    if (-f /home/{{ user }}/gitclear/current/tmp/maintenance.txt) {
        return 503;
    }
{% endif %}

    error_page 503 @maintenance;

    ##
    # Nginx Status
    ##

    location /nginx_status {
        stub_status;
        allow 127.0.0.1;
        deny all;
    }

    location @maintenance {
        if (!-f $request_filename) {
            # We need to fully disable passenger, or it will try to handle the 503 by showing an error page (despite
            # passenger_friendly_error_pages being off)
            passenger_enabled off;

            rewrite ^(.*)$ /503.html break;
        }
    }
}
